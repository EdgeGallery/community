# Tripartite vulnerability investigation

## 1. Developer tripartite dependencies check results

The confirmed vulnerabilities are as follows（Note: the dependent tripartite is already the latest version。）：

| Module      |  Dependent components  |Version| vulnerability|  vulnerability level            |   vulnerability description |  resolved or not |    Description    |
| ---------| --------------------|----------------------|----------------|----------------- |----------------|-----------------|---------------------------------|
|developer| netty-transport  | 4.1.36.Final | CVE-2019-20444  |  Critical        |HttpObjectDecoder.java in Netty before 4.1.44 allows an HTTP header that lacks a colon, which might be interpreted as a separate header with an incorrect syntax, or might be interpreted as an "invalid fold." | no        | servicecomb 1.3.0 Passively dependent tripartite     |
|developer| netty-transport  | 4.1.36.Final | CVE-2019-20445  |  Critical        |HttpObjectDecoder.java in Netty before 4.1.44 allows a Content-Length header to be accompanied by a second Content-Length header, or by a Transfer-Encoding header.| no| servicecomb 1.3.0 Passively dependent tripartite     |
|developer| vertx-core  | 3.6.3 | CVE-2019-17640  |  Critical        |TIn Eclipse Vert.x 3.4.x up to 3.9.4, 4.0.0.milestone1, 4.0.0.milestone2, 4.0.0.milestone3, 4.0.0.milestone4, 4.0.0.milestone5, 4.0.0.Beta1, 4.0.0.Beta2, and 4.0.0.Beta3, StaticHandler doesn't correctly processes back slashes on Windows Operating systems, allowing, escape the webroot folder to the current working directory | no| servicecomb 1.3.0 Passively dependent tripartite     |
|developer|swagger-codegen-cli  | 3.0.21 | CVE-2018-8088 |  Critical        |Netty before 4.1.42.Final mishandles whitespace before the colon in HTTP headers (such as a "Transfer-Encoding : chunked" line), which leads to HTTP request smuggling. | no| Its dependencies are not found in the project dependency tree     |
|developer|swagger-codegen-cli  | 3.0.21 | CVE-2016-6199 |  Critical        |ObjectSocketWrapper.java in Gradle 2.12 allows remote attackers to execute arbitrary code via a crafted serialized object.| no| Its dependencies are not found in the project dependency tree     |
|developer|swagger-codegen-cli  | 3.0.21 | CVE-2019-15052 |  Critical        |he HTTP client in Gradle before 5.6 sends authentication credentials originally destined for the configured host. If that host returns a 30x redirect, Gradle also sends those credentials to all subsequent hosts that the request redirects to. This is similar to CVE-2018-1000007. | no| Its dependencies are not found in the project dependency tree     |
|developer|docker-java-core  | 3.2.7 | CVE-2019-13139 |  High|	In Docker before 18.09.4, an attacker who is capable of supplying or manipulating the build path for the "docker build" command would be able to gain command execution. An issue exists in the way "docker build" processes remote git URLs, and results in command injection into the underlying "git clone" command, leading to code execution in the context of the user executing the "docker build" command. This occurs because git ref can be misinterpreted as a flag. | no| Already the latest version     |
|developer|docker-java-core  | 3.2.7 | CVE-2019-13509 |  High|	In Docker CE and EE before 18.09.8 (as well as Docker EE before 17.06.2-ee-23 and 18.x before 18.03.1-ee-10), Docker Engine in debug mode may sometimes add secrets to the debug log. This applies to a scenario where docker stack deploy is run to redeploy a stack that includes (non external) secrets. It potentially applies to other API users of the stack API if they resend the secret. | no| Already the latest version     |
|developer|docker-java-core  | 3.2.7 | CVE-2019-16884 |  High|	runc through 1.0.0-rc8, as used in Docker through 19.03.2-ce and other products, allows AppArmor restriction bypass because libcontainer/rootfs_linux.go incorrectly checks mount targets, and thus a malicious Docker image can mount over a /proc directory.| no| Already the latest version     |
|developer|docker-java-core  | 3.2.7 | CVE-2019-5736 |  High|	runc through 1.0-rc6, as used in Docker before 18.09.2 and other products, allows attackers to overwrite the host runc binary (and consequently obtain host root access) by leveraging the ability to execute a command as root within one of these types of containers: (1) a new container with an attacker-controlled image, or (2) an existing container, to which the attacker previously had write access, that can be attached with docker exec. This occurs because of file-descriptor mishandling, related to /proc/self/exe. | no| Already the latest version     |
|developer|docker-java-core  | 3.2.7 | CVE-2019-16884 |  High|	runc through 1.0.0-rc8, as used in Docker through 19.03.2-ce and other products, allows AppArmor restriction bypass because libcontainer/rootfs_linux.go incorrectly checks mount targets, and thus a malicious Docker image can mount over a /proc directory.| no| Already the latest version     |
|developer|foundation-ssl  | 1.3.0 | CVE-2004-0009 |  High|	Apache-SSL 1.3.28+1.52 and earlier, with SSLVerifyClient set to 1 or 3 and SSLFakeBasicAuth enabled, allows remote attackers to forge a client certificate by using basic authentication with the "one-line DN" of the target user. | no| servicecomb 1.3.0 Passively dependent tripartite     |
|developer|mybatis-spring  | 2.0.6 | CVE-2020-26945 |  High|	MyBatis before 3.5.6 mishandles deserialization of object streams. | no| mybatis-spring-boot-starter 2.1.4 Passively dependent tripartite     |
|developer|mybatis-spring-boot-starter  | 2.1.4 | CVE-2020-26945 |  High|	MyBatis before 3.5.6 mishandles deserialization of object streams. | no| Already the latest version     |
|developer|netty-transport  | 4.1.36.Final | CVE-2019-16869 |  High|	Netty before 4.1.42.Final mishandles whitespace before the colon in HTTP headers (such as a "Transfer-Encoding : chunked" line), which leads to HTTP request smuggling. | no| servicecomb 1.3.0 Passively dependent tripartite     |
|developer|netty-transport  | 4.1.36.Final | CVE-2020-11612 |  High|	The ZlibDecoders in Netty 4.1.x before 4.1.46 allow for unbounded memory allocation while decoding a ZlibEncoded byte stream. An attacker could send a large ZlibEncoded byte stream to the Netty server, forcing the server to allocate all of its free memory to a single decoder. | no| servicecomb 1.3.0 Passively dependent tripartite     |


# Screenshots
## Critical        
![输入图片说明](https://images.gitee.com/uploads/images/2021/0326/153240_16b24ae3_5504908.png "严重.PNG")
## High
![输入图片说明](https://images.gitee.com/uploads/images/2021/0326/154519_d0131417_5504908.png "high-1.PNG")
![输入图片说明](https://images.gitee.com/uploads/images/2021/0326/154530_e6e11fd0_5504908.png "high-2.PNG")
